<?php

namespace XH;

/**
 * CSRF Protection Class (PHP 8 Enhanced)
 * Assuming XH_startSession() and XH_exit() exist globally or are autoloaded.
 * Consider replacing these with dependency injection (e.g., a SessionInterface)
 * and exceptions for better testability and flexibility in larger applications.
 *
 * Provides Cross-Site Request Forgery protection using session-based tokens.
 *
 * @author    The CMSimple_XH developers <devs@cmsimple-xh.org>
 * @copyright 2013-2021 The CMSimple_XH developers <http://cmsimple-xh.org/?The_Team>
 * @copyright GNU GPLv3 <http://www.gnu.org/licenses/gpl-3.0.en.html>
 * @since     1.6
 * @see       @ref csrf  
 * modified 2025 by github.com/g7sim
 */
 
class CSRFProtection
{
    /**
     * The CSRF token generated for the *next* request - Null until generated by tokenInput().
     */
    private ?string $currentToken = null;

    /**
     * Flag indicating if a new token should be generated per request.
     */
    private bool $generatePerRequest;

    /**
     * Initializes a new CSRFProtection instance.
     * @param string $keyName The name used for the session key and the form input field.
     * @param bool $perRequest : If true, a new token is generated for each request.
     * If false (default), a token persists for the entire session duration once generated.
     */
    public function __construct(
        /**
         * The name of the session key and input name of the CSRF token.
         */
        private string $keyName = 'xh_csrf_token',
        bool $perRequest = false
    ) {
        $this->generatePerRequest = $perRequest;

        /* If using session-persistent tokens, try to load the existing one.
         This token will be used by tokenInput() if it's called in this request,
        unless generatePerRequest is true.   */
		
        if (!$this->generatePerRequest) {
            XH_startSession(); // Ensure session is started before accessing $_SESSION
            if (isset($_SESSION[$this->keyName])) {
                // Ensure it's treated as a string
                $this->currentToken = (string) $_SESSION[$this->keyName];
            }
        }
    }

    /**
     * Generates (if needed) and returns a hidden HTML input field containing the CSRF token.
     * This method generates the token that should be stored (using store() and validated in the *next* request.
     * @return string HTML hidden input field.
     */
    public function tokenInput(): string
    {
        /* Generate a new token if:
         1. No token currently exists ($this->currentToken is null), OR
         2. We require a new token for every request ($this->generatePerRequest is true). */
        if ($this->currentToken === null || $this->generatePerRequest) {
            $this->currentToken = bin2hex(random_bytes(32));
        }

        return sprintf(
            '<input type="hidden" name="%s" value="%s">',
            htmlspecialchars($this->keyName, ENT_QUOTES, 'UTF-8'),
            htmlspecialchars($this->currentToken, ENT_QUOTES, 'UTF-8')
        );
    }

    /**
     * Validates the submitted CSRF token against the one stored in the session.
     * Responds with "403 Forbidden" and exits if the token is missing or invalid.
     * Call this early in your request processing for protected endpoints (POST/PUT/DELETE etc.).
    */
    public function check(): void
    {
        $submittedToken = $_POST[$this->keyName] ?? $_GET[$this->keyName] ?? null;

        if ($submittedToken === null) {
            $this->handleInvalidToken('CSRF token missing from request.');
            return; 
        }

        XH_startSession(); 

        $sessionToken = $_SESSION[$this->keyName] ?? null;

        if ($sessionToken === null) {
            $this->handleInvalidToken('CSRF token missing or expired in session.');
            return;
        }

        if (!hash_equals((string) $sessionToken, (string) $submittedToken)) {
            $this->handleInvalidToken('Invalid CSRF token provided.');
            return; 
        }

        // Optional: If using per-request tokens, invalidate the token immediately after successful validation
        if ($this->generatePerRequest) {
            unset($_SESSION[$this->keyName]);
         }
    }

    /**
     * Stores the current CSRF token (`$this->currentToken`) in the session.
     */
    public function store(): void
    {
        if ($this->currentToken !== null) {
            XH_startSession(); 
            $_SESSION[$this->keyName] = $this->currentToken;
        }
    }

    /**
     * Handles the response for an invalid or missing CSRF token.
     */
    private function handleInvalidToken(string $message): void
    {
        error_log('CSRF Check Failed: ' . $message
            . ' | IP: ' . ($_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN')
            . ' | User Agent: ' . ($_SERVER['HTTP_USER_AGENT'] ?? 'UNKNOWN')
        );

        if (!headers_sent()) {
            header('HTTP/1.1 403 Forbidden');
        }

        XH_exit('Error: Invalid request. Please try again.'); 
    }
}